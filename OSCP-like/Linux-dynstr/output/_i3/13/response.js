var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Fri, 04 Nov 2022 06:24:14 GMT\x0aServer: Apache/2.4.41 (Ubuntu)\x0aLast-Modified: Fri, 12 Mar 2021 18:23:04 GMT\x0aETag: \x221c50-5bd5afda97200-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-2207/2208\x0aContent-Length: 2208\x0aKeep-Alive: timeout=5, max=53\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*!\x0a * imagesLoaded v3.0.2\x0a * JavaScript is all like \x22You images are done yet or what?\x22\x0a */\x0a\x0a( function( window ) {\x0a\x0a\x27use strict\x27;\x0a\x0avar $ = window.jQuery;\x0avar console = window.console;\x0avar hasConsole = typeof console !== \x27undefined\x27;\x0a\x0a// -------------------------- helpers -------------------------- //\x0a\x0a// extend objects\x0afunction extend( a, b ) {\x0a  for ( var prop in b ) {\x0a    a[ prop ] = b[ prop ];\x0a  }\x0a  return a;\x0a}\x0a\x0avar objToString = Object.prototype.toString;\x0afunction isArray( obj ) {\x0a  return objToString.call( obj ) === \x27[object Array]\x27;\x0a}\x0a\x0a// turn element or nodeList into an array\x0afunction makeArray( obj ) {\x0a  var ary = [];\x0a  if ( isArray( obj ) ) {\x0a    // use object if already an array\x0a    ary = obj;\x0a  } else if ( typeof obj.length === \x27number\x27 ) {\x0a    // convert nodeList to array\x0a    for ( var i=0, len = obj.length; i \x3c len; i++ ) {\x0a      ary.push( obj[i] );\x0a    }\x0a  } else {\x0a    // array of single index\x0a    ary.push( obj );\x0a  }\x0a  return ary;\x0a}\x0a\x0a// --------------------------  -------------------------- //\x0a\x0afunction defineImagesLoaded( EventEmitter, eventie ) {\x0a\x0a  /**\x0a   * @param {Array, Element, NodeList, String} elem\x0a   * @param {Object or Function} options - if function, use as callback\x0a   * @param {Function} onAlways - callback function\x0a   */\x0a  function ImagesLoaded( elem, options, onAlways ) {\x0a    // coerce ImagesLoaded() without new, to be new ImagesLoaded()\x0a    if ( !( this instanceof ImagesLoaded ) ) {\x0a      return new ImagesLoaded( elem, options );\x0a    }\x0a    // use elem as selector string\x0a    if ( typeof elem === \x27string\x27 ) {\x0a      elem = document.querySelectorAll( elem );\x0a    }\x0a\x0a    this.elements = makeArray( elem );\x0a    this.options = extend( {}, this.options );\x0a\x0a    if ( typeof options === \x27function\x27 ) {\x0a      onAlways = options;\x0a    } else {\x0a      extend( this.options, options );\x0a    }\x0a\x0a    if ( onAlways ) {\x0a      this.on( \x27always\x27, onAlways );\x0a    }\x0a\x0a    this.getImages();\x0a\x0a    if ( $ ) {\x0a      // add jQuery Deferred object\x0a      this.jqDeferred = new $.Deferred();\x0a    }\x0a\x0a    // HACK check async to allow time to bind listeners\x0a    var _this = this;\x0a    setTimeout( function() {\x0a      _this.check();\x0a    });\x0a  }\x0a\x0a  ImagesLoaded.prototype = new EventEmitter();\x0a\x0a  ImagesLoaded.prototype.options = {};\x0a\x0a  ImagesLoaded.prototype.getImages = function() {\x0a    this.images = [];\x0a\x0a    // filter & find items if we have an item selector\x0a    for ( var i=0, len = this.elements.length; i \x3c len; i++ ) {\x0a      var elem = this.elements[i];\x0a      // filter siblings\x0a      if ( elem.nodeName === \x27IMG\x27 ) {\x0a        this.addImage( elem );\x0a      }\x0a      // find children\x0a      var childElems = elem.querySelectorAll(\x27img\x27);\x0a      // concat childElems to filterFound array\x0a      for ( var j=0, jLen = childElems.length; j \x3c jLen; j++ ) {\x0a        var img = childElems[j];\x0a        this.addImage( img );\x0a      }\x0a    }\x0a  };\x0a\x0a  /**\x0a   * @param {Image} img\x0a   */\x0a  ImagesLoaded.prototype.addImage = function( img ) {\x0a    var loadingImage = new LoadingImage( img );\x0a    this.images.push( loadingImage );\x0a  };\x0a\x0a  ImagesLoaded.prototype.check = function() {\x0a    var _this = this;\x0a    var checkedCount = 0;\x0a    var length = this.images.length;\x0a    this.hasAnyBroken = false;\x0a    // complete if no images\x0a    if ( !length ) {\x0a      this.complete();\x0a      return;\x0a    }\x0a\x0a    function onConfirm( image, message ) {\x0a      if ( _this.options.debug && hasConsole ) {\x0a        console.log( \x27confirm\x27, image, message );\x0a      }\x0a\x0a      _this.progress( image );\x0a      checkedCount++;\x0a      if ( checkedCount === length ) {\x0a        _this.complete();\x0a      }\x0a      return true; // bind once\x0a    }\x0a\x0a    for ( var i=0; i \x3c length; i++ ) {\x0a      var loadingImage = this.images[i];\x0a      loadingImage.on( \x27confirm\x27, onConfirm );\x0a      loadingImage.check();\x0a    }\x0a  };\x0a\x0a  ImagesLoaded.prototype.progress = function( image ) {\x0a    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\x0a    this.emit( \x27progress\x27, this, image );\x0a    if ( this.jqDeferred ) {\x0a      this.jqDeferred.notify( this, image );\x0a    }\x0a  };\x0a\x0a  ImagesLoaded.prototype.complete = function() {\x0a    var eventName = this.hasAnyBroken ? \x27fail\x27 : \x27done\x27;\x0a    this.isComplete = true;\x0a    this.emit( eventName, this );\x0a    this.emit( \x27always\x27, this );\x0a    if ( this.jqDeferred ) {\x0a      var jqMethod = this.hasAnyBroken ? \x27reject\x27 : \x27resolve\x27;\x0a      this.jqDeferred[ jqMethod ]( this );\x0a    }\x0a  };\x0a\x0a  // -------------------------- jquery -------------------------- //\x0a\x0a  if ( $ ) {\x0a    $.fn.imagesLoaded = function( options, callback ) {\x0a      var instance = new ImagesLoaded( this, options, callback );\x0a      return instance.jqDeferred.promise( $(this) );\x0a    };\x0a  }\x0a\x0a\x0a  // --------------------------  -------------------------- //\x0a\x0a  var cache = {};\x0a\x0a  function LoadingImage( img ) {\x0a    this.img = img;\x0a  }\x0a\x0a  LoadingImage.prototype = new EventEmitter();\x0a\x0a  LoadingImage.prototype.check = function() {\x0a    // first check cached any previous images that have same src\x0a    var cached = cache[ this.img.src ];\x0a    if ( cached ) {\x0a      this.useCached( cached );\x0a      return;\x0a    }\x0a    // add this to cache\x0a    cache[ this.img.src ] = this;\x0a\x0a    // If complete is true and browser supports natural sizes,\x0a    // try to check for image status manually.\x0a    if ( this.img.complete && this.img.naturalWidth !== undefined ) {\x0a      // report based on naturalWidth\x0a      this.confirm( this.img.naturalWidth !== 0, \x27naturalWidth\x27 );\x0a      return;\x0a    }\x0a\x0a    // If none of the checks above matched, simulate loading on detached element.\x0a    var proxyImage = this.proxyImage = new Image();\x0a    eventie.bind( proxyImage, \x27load\x27, this );\x0a    eventie.bind( proxyImage, \x27error\x27, this );\x0a    proxyImage.src = this.img.src;\x0a  };\x0a\x0a  LoadingImage.prototype.useCached = function( cached ) {\x0a    if ( cached.isConfirmed ) {\x0a      this.confirm( cached.isLoaded, \x27cached was confirmed\x27 );\x0a    } else {\x0a      var _this = this;\x0a      cached.on( \x27confirm\x27, function( image ) {\x0a        _this.confirm( image.isLoaded, \x27cache emitted confirmed\x27 );\x0a        return true; // bind once\x0a      });\x0a    }\x0a  };\x0a\x0a  LoadingImage.prototype.confirm = function( isLoaded, message ) {\x0a    this.isConfirmed = true;\x0a    this.isLoaded = isLoaded;\x0a    this.emit( \x27confirm\x27, this, message );\x0a  };\x0a\x0a  // trigger specified handler for event type\x0a  LoadingImage.prototype.handleEvent = function( event ) {\x0a    var method = \x27on\x27 + event.type;\x0a    if ( this[ method ] ) {\x0a      this[ method ]( event );\x0a    }\x0a  };\x0a\x0a  LoadingImage.prototype.onload = function() {\x0a    this.confirm( true, \x27onload\x27 );\x0a    this.unbindProxyEvents();\x0a  };\x0a\x0a  LoadingImage.prototype.onerror = function() {\x0a    this.confirm( false, \x27onerror\x27 );\x0a    this.unbindProxyEvents();\x0a  };\x0a\x0a  LoadingImage.prototype.unbindProxyEvents = function() {\x0a    eventie.unbind( this.proxyImage, \x27load\x27, this );\x0a    eventie.unbind( this.proxyImage, \x27error\x27, this );\x0a  };\x0a\x0a  // -----  ----- //\x0a\x0a  return ImagesLoaded;\x0a}\x0a\x0a// -------------------------- transport -------------------------- //\x0a\x0aif ( typeof define === \x27function\x27 && define.amd ) {\x0a  // AMD\x0a  define( [\x0a      \x27eventEmitter\x27,\x0a      \x27eventie\x27\x0a    ],\x0a    defineImagesLoaded );\x0a} else {\x0a  // browser global\x0a  window.imagesLoaded = defineImagesLoaded(\x0a    window.EventEmitter,\x0a    window.eventie\x0a  );\x0a}\x0a\x0a})( window );'}